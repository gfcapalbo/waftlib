#!/usr/bin/env python
# Version: v.22.05.30
import os
import argparse
from subprocess import run, PIPE
from dotenv import load_dotenv

import yaml
from waftlib import (
    PRIVATE,
    REPOS_YAML,
    SRC_DIR,
    logger,
    ODOO_VERSION,
)

SCRIPT_PATH = os.path.abspath(os.path.dirname(__file__))
os.environ["ODOO_WORK_DIR"] = os.path.realpath(os.path.join(SCRIPT_PATH, "../.."))
load_dotenv(os.path.join(os.environ["ODOO_WORK_DIR"], ".env-default"))
load_dotenv(os.path.join(os.environ["ODOO_WORK_DIR"], ".env-shared"), override=True)
load_dotenv(os.path.join(os.environ["ODOO_WORK_DIR"], ".env-secret"), override=True)

parser = argparse.ArgumentParser(
    prog="get_pins",
    description="Fetch current pins of this instance",
    epilog="Outputs pinned repo.yaml",
)

parser.add_argument("--only-base")
args = parser.parse_args()
current_heads = {}
all_commits = {}


class CustomDumper(yaml.Dumper):
    """
    We want order of keys intact so that the output is the same order than source.
    Unfortunately PyYAML orders yaml output alphabetically on dump.
    pyyaml 5.1 has an option to disable alphabetical orderng of dumps, but often our
    wafts have a version < 5.1.
    for this reason i made a custom dumper to have an "unordered" dump, without
    affecting the default behaviour of pyyaml dump. This script supports pyYAML<5.1.
    Our output will therefore have the same order as given input.
    """

    def represent_dict_preserve_order(self, data):
        return self.represent_dict(data.items())


def split_line(line):
    splitted_lines = line.split(" ")
    for sl in splitted_lines:
        if sl == "":
            splitted_lines.pop(splitted_lines.index(sl))
    return splitted_lines


def is_in_history(value, history):
    for commit in history:
        if commit[:8] == value[:8]:
            return True
    return False


def preprocess_merge(doc, repo, merge):
    remotes = doc[repo]["remotes"].keys()
    splitted_merge = [x for x in merge.split(" ") if x != ""]
    if splitted_merge[0] not in remotes:
        logger.debug("Invalid Remote on line: %s" % merge)
        raise ValueError
    repo_path = os.path.abspath(os.path.join(SRC_DIR, repo))
    if not os.path.exists(repo_path):
        logger.debug("build incomplete")
        exit()
    return repo_path, splitted_merge


def get_branchname(splitted_merge):
    return splitted_merge[1].replace("${ODOO_VERSION}", ODOO_VERSION)


def update_repo_commits_and_heads(repo_path, repo):
    os.chdir(repo_path)
    allrev = run(["git", "rev-list", "HEAD"], stdout=PIPE, stderr=PIPE)
    lrev = run(["git", "rev-parse", "HEAD"], stdout=PIPE, stderr=PIPE)
    # no return updating globals.
    current_heads[repo] = lrev.stdout.decode("utf-8").replace("\n", "").replace("'", "")
    all_commits[repo] = allrev.stdout.decode("utf-8").replace("\n", ",").split(",")


def get_merge_type(splitted_merge):
    """
    Possible syntaxes for merges:

    <remote> <branch>     merge_type=1
    <remote> <PIN>        merge_type=2
    <remote> <branch> <PIN>     merge_type=3
    merge_type=0  "invalid"
    """
    if len(splitted_merge) == 3:
        return 3
    else:
        if is_in_history(splitted_merge[1], all_commits.get(repo, [])):
            return 2
        else:
            return 1
    return 0  # unreachable.


def process_merge(doc, repo, merge, index):
    repo_path, splitted_merge = preprocess_merge(doc, repo, merge)
    # will update all_commits[repo] and current_heads[repo] globals.
    update_repo_commits_and_heads(repo_path, repo)
    env = dict(os.environ, **doc.get("ENV", {}))
    wd = os.getcwd()
    merge_type = get_merge_type(splitted_merge)
    if merge_type == 3:
        # merge_type #3
        branchname = get_branchname(splitted_merge)
        current_pin = run(
            [
                "git",
                "merge-base",
                "HEAD",
                "".join([splitted_merge[0], "/", branchname]),
            ],
            stdout=PIPE,
            stderr=PIPE,
        )
        if splitted_merge[2] != current_pin:
            splitted_merge[2] = current_pin
    if merge_type == 2:
        # <remote> <PIN> merge_type line
        splitted_merge[1] = current_heads.get(repo, "")
    if merge_type == 1:
        # <remote> <branch> merge_type line
        # merge_type #1
        branchname = get_branchname(splitted_merge)
        current_pin = (
            run(
                [
                    "git",
                    "merge-base",
                    "HEAD",
                    "".join([splitted_merge[0], "/", branchname]),
                ],
                stdout=PIPE,
                stderr=PIPE,
            )
            .stdout.decode("utf-8")
            .replace("\n", "")
        )
        splitted_merge.append(current_pin)
    os.chdir(wd)
    if merge_type == 0:
        logger.debug("Invalid Repo of unrecognized merge_type: %s" % splitted_merge)
        raise ValueError
    return " ".join(splitted_merge)


def main():
    """
    parsing directly repos.yaml, if something is not in addons.yaml, branch will still
    be in folder, but may not be included in addons. Nothing changes.
    """
    with open(REPOS_YAML) as yaml_file:
        for doc in yaml.safe_load_all(yaml_file):
            for repo in doc:
                if repo in {PRIVATE, "ONLY", "ENV"}:
                    continue
                target = doc[repo]["target"] or False
                has_target = target and True or False
                processed_target = False
                if has_target:
                    doc[repo]["target"] = process_merge(doc, repo, target, 0)
                # main branch is defined as target or in absence of target, merge[0]
                main_branch = target or merge[0]
                main_branch = split_line(main_branch)[0]
                for merge in doc[repo]["merges"]:
                    index = doc[repo]["merges"].index(merge)
                    # if target exists and only base is selected , just pin target.
                    if (
                        (index > 0 or (has_target and index >= 0))
                        and bool(args.only_base)
                    ) == True:
                        continue
                    doc[repo]["merges"][index] = process_merge(doc, repo, merge, index)
                    lastrev = (
                        run(
                            [
                                "git",
                                "merge-base",
                                "HEAD",
                                "".join([splitted_merge[0], "/", branchname]),
                            ],
                            stdout=PIPE,
                            stderr=PIPE,
                        )
                        .stdout.decode("utf-8")
                        .replace("\n", "")
                    )
                    # we now calculate the needed depth of this branch
                    mindepth = (
                        run(
                            ["git", "rev-list", "HEAD", "^$" + lastrev, "--count"],
                            stdout=PIPE,
                            stderr=PIPE,
                        )
                        .stdout.decode("utf-8")
                        .replace("\n", "")
                    )
            CustomDumper.add_representer(
                dict, CustomDumper.represent_dict_preserve_order
            )
            print(yaml.dump(doc, Dumper=CustomDumper))


if os.path.isfile(REPOS_YAML) and __name__ == "main":
    main()
else:
    logger.debug("no %s  repository file found" % REPOS_YAML)
    raise ValueError
