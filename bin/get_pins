#!/usr/bin/env python
# Version: v.22.05.30
# -*- coding: utf-9 -*-
import os
import argparse
from subprocess import run, PIPE
from dotenv import load_dotenv

import yaml
from waftlib import (
    PRIVATE,
    REPOS_YAML,
    SRC_DIR,
    logger,
    ODOO_VERSION,
)

SCRIPT_PATH = os.path.abspath(os.path.dirname(__file__))
os.environ["ODOO_WORK_DIR"] = os.path.realpath(os.path.join(SCRIPT_PATH, "../.."))
load_dotenv(os.path.join(os.environ["ODOO_WORK_DIR"], ".env-default"))
load_dotenv(os.path.join(os.environ["ODOO_WORK_DIR"], ".env-shared"), override=True)
load_dotenv(os.path.join(os.environ["ODOO_WORK_DIR"], ".env-secret"), override=True)

parser = argparse.ArgumentParser(
    prog="get_pins",
    description="Fetch current pins of this instance",
    epilog="Outputs pinned repo.yaml",
)

parser.add_argument("--only-base")
args = parser.parse_args()
current_heads = {}
all_commits = {}


class CustomDumper(yaml.Dumper):
    """
    We want order of keys intact so that the output is the same order than source.
    Unfortunately PyYAML orders yaml output alphabetically  on dump.
    pyyaml 5.1 has an option to disable alphabetical orderng of dumps, but often our
    wafts have a version < 5.1.
    for this reason i made a custom dumper to have an "unordered" dump, without
    affecting the default behaviour of pyyaml dump. This script supports pyYAML<5.1.
    """

    def represent_dict_preserve_order(self, data):
        return self.represent_dict(data.items())


def split_line(line):
    splitted_lines = line.split(" ")
    for sl in splitted_lines:
        if sl == "":
            splitted_lines.pop(splitted_lines.index(sl))
    return splitted_lines


def is_in_history(value, history):
    for commit in history:
        if commit[:8] == value[:8]:
            return True
    return False


def preprocess_merge(doc, repo, merge):
    remotes = doc[repo]["remotes"].keys()
    splitted_merge = [x for x in merge.split(" ") if x != ""]
    if splitted_merge[0] not in remotes:
        logger.debug("Invalid Remote on line: %s" % merge)
        raise ValueError
    repo_path = os.path.abspath(os.path.join(SRC_DIR, repo))
    if not os.path.exists(repo_path):
        logger.debug("build incomplete")
        exit()
    return repo_path, splitted_merge


def process_merge(doc, repo, merge, index):
    """
    Possible syntaxes for merges:

    <remote> <branch>     merge_type=1
    <remote> <PIN>        merge_type=2
    <remote> <branch> <PIN>     merge_type=3
    merge_type=0 "invalid"
    """
    repo_path, splitted_merge = preprocess_merge(doc, repo, merge)
    merge_type = 0  # invalid
    env = dict(os.environ, **doc.get("ENV", {}))
    wd = os.getcwd()
    os.chdir(repo_path)
    allrev = run(["git", "rev-list", "HEAD"], stdout=PIPE, stderr=PIPE)
    lrev = run(["git", "rev-parse", "HEAD"], stdout=PIPE, stderr=PIPE)
    current_heads[repo] = lrev.stdout.decode("utf-8").replace("\n", "").replace("'", "")
    all_commits[repo] = allrev.stdout.decode("utf-8").replace("\n", ",").split(",")
    if len(splitted_merge) == 3:
        # <remote> <branch> <PIN> merge_type line
        merge_type = 3
        branchname = splitted_merge[1].replace("${ODOO_VERSION}", ODOO_VERSION)
        current_pin = run(
            [
                "git",
                "merge-base",
                "HEAD",
                "".join([splitted_merge[0], "/", branchname]),
            ],
            stdout=PIPE,
            stderr=PIPE,
        )
        if splitted_merge[2] != current_pin:
            splitted_merge[2] = current_pin
    else:
        if is_in_history(splitted_merge[1], all_commits.get(repo, [])):
            # <remote> <PIN> merge_type line
            merge_type = 2
            splitted_merge[1] = current_heads.get(repo, "")
        else:
            # <remote> <branch> merge_type line
            merge_type = 1
            branchname = splitted_merge[1].replace("${ODOO_VERSION}", ODOO_VERSION)
            current_pin = (
                run(
                    [
                        "git",
                        "merge-base",
                        "HEAD",
                        "".join([splitted_merge[0], "/", branchname]),
                    ],
                    stdout=PIPE,
                    stderr=PIPE,
                )
                .stdout.decode("utf-8")
                .replace("\n", "")
            )
            splitted_merge.append(current_pin)
        os.chdir(wd)
        if merge_type == 0:
            logger.debug("Invalid Repo of unrecognized merge_type: %s" % splitted_merge)
            raise ValueError
    return " ".join(splitted_merge)


def update_pins():
    """
    parsing directly repos.yaml, if something is not in addons.yaml, branch will still
    be in folder, but may not be included in addons. Nothing changes.
    """
    with open(REPOS_YAML) as yaml_file:
        for doc in yaml.safe_load_all(yaml_file):
            for repo in doc:
                if repo in {PRIVATE, "ONLY", "ENV"}:
                    continue
                target = doc[repo]["target"] or False
                has_target = target and True or False
                processed_target = False
                if has_target:
                    doc[repo]["target"] = process_merge(doc, repo, target, 0)
                for merge in doc[repo]["merges"]:
                    index = doc[repo]["merges"].index(merge)
                    # if target exists and only base is selected , just pin target.
                    if (
                        (index > 0 or (has_target and index >= 0))
                        and bool(args.only_base)
                    ) == True:
                        continue
                    doc[repo]["merges"][index] = process_merge(doc, repo, merge, index)

            CustomDumper.add_representer(
                dict, CustomDumper.represent_dict_preserve_order
            )
            print(yaml.dump(doc, Dumper=CustomDumper))


if os.path.isfile(REPOS_YAML):
    update_pins()
